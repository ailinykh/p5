#!/usr/bin/env python3

kStatusOpen = "open"
kStatusNew = "new"
kStatusDelete = "delete"
kStatusUnchanged = "same/open"
# these are defined by `p4`, you can't change them
kStatusMissing = "missing"
kStatusDiff = "diff"
kStatusSame = "same"

import subprocess, sys

def shellEscape(p):
    if set(p).intersection( set(r'''~!@#$%^&*(){}[]"'\|<>? ''') ):
        return "'" + p.replace("'", "\'\"\'\"\'") + "'"
    return p

def p4escape(path):
    return path.replace("%","%25").replace("@","%40").replace("#","%23").replace("*","%2A")

def p4unescape(path):
    return path.replace("%40","@").replace("%23","#").replace("%2A","*").replace("%25","%")

def check_workspace():
    try:
        output = subprocess.check_output("p4 info", shell=True, universal_newlines=True)
    except:
        print("Can not run `p4 info`. Make sure you are logged in (`p4 login`).", file=sys.stderr)
        raise
    if "Client unknown." in output:
        return False
    return True

def inspect(args):
    if not check_workspace():
        print("No workspace found. You must first create it manually or with `p5 sync -f`.", file=sys.stderr)
        raise SystemExit(1)

    import re, os.path, fnmatch
    output = subprocess.check_output("p4 client -o", shell=True, universal_newlines=True)
    client = re.search(r'''^Client:\s+(.*)''', output, re.M).group(1)
    root = re.search(r'''^Root:\s+(.*)''', output, re.M).group(1)
    statuses = {}
    
    print("Checking opened files...", file=sys.stderr)
    output = subprocess.check_output(r"""p4 opened | sed -e 's/^\(.*\)#.*/\1/' | xargs p4 where | awk '//{print$3;}'""", shell=True).decode(errors='replace')
    for path in output.splitlines():
        statuses[p4unescape(path)] = kStatusOpen
    
    print("Checking unopened tracked files...", file=sys.stderr)
    output = subprocess.check_output("p4 diff -sl", shell=True).decode(errors='replace')
    for match in re.finditer(r'''^(\w+)\s+(.*)''', output, re.M):
        status, path = match.groups()
        # files that are already oped for deletion will be 'missing' here
        if (status == kStatusMissing) and (path in statuses):
            status = kStatusDelete
        statuses[path] = status
    
    print("Searching unchanged files...", file=sys.stderr)
    output = subprocess.check_output("p4 diff -sr", shell=True).decode(errors='replace')
    for path in output.splitlines():
        statuses[path] = kStatusUnchanged
    
    print("Finding untracked (new) files...", file=sys.stderr)
    output = subprocess.check_output(r'''find "%s" -type f''' % root, shell=True, universal_newlines=True)
    for phys in output.splitlines():
        if phys not in statuses:
            statuses[phys] = kStatusNew
    
    p4ignore = os.path.join(root, ".p4ignore")
    ignores = list(map(str.strip, open(p4ignore, "r").readlines())) if os.path.exists(p4ignore) else []
    while "" in ignores: 
        ignores.remove("")
    ignores.append("/.perforce")
    def is_ignored(path):
        if statuses[path] == kStatusSame:
            return True
        basename = os.path.basename(path)
        relpath = os.path.relpath(path, root)
        for patt in ignores:
            # shortcut for speed
            if (basename == patt) or (relpath == patt):
                return True
            # with '/', path is matched, otherwise, filename only
            if fnmatch.fnmatch( (relpath if ('/' in patt) else basename), patt):
                return True
            # exact full path patterns start with /
            if (patt[0] == '/') and fnmatch.fnmatch(relpath, patt[1:]):
                return True
        return False

    command_from_status = { kStatusMissing : "delete", kStatusDiff : "edit", kStatusNew : "add", kStatusOpen : None, kStatusDelete : None, kStatusUnchanged : "revert" }
    edit_part, revert_part, opened_part = [], [], []
    destination_from_status = { kStatusMissing : edit_part, kStatusDiff : edit_part, kStatusNew : edit_part, kStatusOpen : opened_part, kStatusDelete : opened_part, kStatusUnchanged : revert_part }
    for path in sorted(statuses.keys()):
        if is_ignored(path):
            continue
        status = statuses[path]
        command = command_from_status[status]
        destination_list = destination_from_status[status]
        destination_list.append((status, command, path))
    return (edit_part, revert_part, opened_part)

def status(args):
    edit_part, revert_part, opened_part = inspect(args)

    for status, _, path in edit_part:
        print("{0:>12} {1}".format(status, path))
    for status, _, path in revert_part:
        print("{0:>12} {1}".format(status, path))
    for status, _, path in opened_part:
        print("{0:>12} {1}".format(status, path))

def reconcile(args):
    import os
    editor = os.getenv("EDITOR")
    if not editor:
        warn_about_vi = True
        editor = "vi"
    else:
        warn_about_vi = False

    edit_part, revert_part, opened_part = inspect(args)

    def warn(f):
        nonlocal warn_about_vi
        if warn_about_vi:
            print("""
# You are running `vi` because EDITOR environment variable is not set.
# To save and exit, type `:wq<Enter>`. To delete the line under the cursor, type `dd`.
# Select multiple lines with `V` then delete selection with `d` or cancel it with `Esc`. To undo, type `u`.
# To exit without saving, type `:q!`
""", end='', file=f)
            warn_about_vi = False

    if edit_part or revert_part:
        tempy_path = "/tmp/{0}_pfs_reconcile.txt".format(os.getenv("USER"))
        tempy = open(tempy_path,"w")
        print("""\
#!/bin/sh
#
# Save and exit to perform these commands. Edit to remove unwanted commands.
# Quit without saving to cancel.
""", end='', file=tempy)
        warn(tempy)

        if edit_part: print("\n\n# Unopened changes:\n", file=tempy)
        for _, command, path in edit_part:
            flag = ""
            escapedPath = shellEscape(path)
            if ('@' in path) or ('#' in path) or ('%' in path):
                if command == "add":
                    flag = " -f"
                elif (command == "delete") or (command == "edit"):
                    escapedPath = p4escape(escapedPath)
            print("p4 {0}{1} {2}".format(command, flag, escapedPath), file=tempy)

        if revert_part: print("\n\n# Opened but not changed (revert recommended):\n", file=tempy)
        for _, _, path in revert_part:
            print("p4 revert {0}".format(shellEscape(path)), file=tempy)

        if opened_part: print("\n\n# For information only. Opened files:\n", file=tempy)
        for status, _, path in opened_part:
            print("# {0:>12} {1}".format(status, path), file=tempy)

        tempy.close()
        del tempy
        mtime = os.stat(tempy_path).st_mtime
        if os.system("'{0}' '{1}'".format(editor, tempy_path)):
            print("Editor exited with error status, abort.")
        elif mtime == os.stat(tempy_path).st_mtime:
            print("File not saved => aborted. The file is saved at\n\t{0}".format(tempy_path))
        else:
            if 0 == os.system("/bin/sh '{0}'".format(tempy_path)):
                os.unlink(tempy_path)
            else:
                print("Error performing commands, whatever. The file is saved at\n\t{0}".format(tempy_path))
    else:
        print("\nNothing to reconcile.")
        if opened_part:
            print()
            print("The list of already opened files:")
            for status, _, path in opened_part:
                print("{0:>12} {1}".format(status, path))

def diff(args):
    edit_part, revert_part, opened_part = inspect(args)

    paths = '\n'.join(path for _,_,path in edit_part+opened_part).encode('utf-8')

    import os, subprocess
    pager_cmd = os.getenv('PFS_PAGER') or os.getenv('PAGER') or '/usr/bin/less -R'
    sh = subprocess.Popen("p4 -x - diff -f | %s" % pager_cmd, shell=True, stdin=subprocess.PIPE)
    sh.communicate(paths)

def sync(args):
    workspace_exists = check_workspace()
    if (not args.create) and (not workspace_exists):
        print("No workspace here. Run with `-f` if you want to auto create it.", file=sys.stderr)
        raise SystemExit(1)

    import os, re, os.path, fnmatch
    output = subprocess.check_output("p4 client -o", shell=True, universal_newlines=True)
    client = re.search(r'''^Client:\s+(.*)''', output, re.M).group(1)
    root = re.search(r'''^Root:\s+(.*)''', output, re.M).group(1)

    # update clientspec
    workspace_config_filename = os.path.join(root, '.perforce')
    if (workspace_exists or args.create) and os.path.exists(workspace_config_filename):
        m = re.search(r'''P5CLIENTSPEC\s*=\s*(.*)\s*$''', open(workspace_config_filename, "r").read(), re.M)
        if m:
            clientspec_path = m.group(1)
            if clientspec_path.startswith('//'):
                ### TODO: run p4 diff -sl, and if this file is locally modified, make sure to open it and use it instead.
                # be sure to print notice after sync about that!
                clientspec_contents = subprocess.check_output("p4 print -q " + shellEscape(clientspec_path), shell=True, universal_newlines=True)
            else:
                clientspec_contents = open(clientspec_path, "r").read()

            # replace whatever client name there is with current client name
            clientspec_contents = re.sub(r'''^("?[+\-]?//(?:.*?)\s+"?//)([^/]+)(/.*)$''', r'''\1%s\3''' % client, clientspec_contents, flags=re.M)
            # erase comments and empty lines, and add tabs as needed by `p4 client -i`
            clientspec_contents = re.sub(r'''^\s*;.*$''', "", clientspec_contents, flags=re.M)
            clientspec_contents = os.linesep.join([ ("\t"+s) for s in clientspec_contents.splitlines() if s.strip()])
    
            # todo: fetch full list of remote files with old spec, then compare to the new spec
            # because if a folder is deleted from mapping, some old files may start being displayed as 'new'

            # recreate client
            new_clientspec = output
            new_clientspec = re.sub(r'''^(Options:\s+)(.*)$''', r'''\1allwrite noclobber compress unlocked modtime rmdir''', new_clientspec, flags=re.M)
            new_clientspec = re.sub(r'''^(.*\nView:\s*\n).*$''', r'''\1''' + clientspec_contents, new_clientspec, flags=re.DOTALL)
            proc = subprocess.Popen("p4 client -i", stdin=subprocess.PIPE, shell=True, universal_newlines=True)
            proc.communicate(input=new_clientspec)
            if proc.returncode != 0:
                open("/tmp/clientspec.txt", "w").write(new_clientspec)
                print("The attempted workspace definition is saved to /tmp/p5clientspec.txt", file=sys.stderr)
                raise SystemExit(1)
            workspace_exists = check_workspace()

    if not workspace_exists:
        print("Creating workspace failed. Make sure you have `.perforce` file with `P4CLIENT` and optionally `P5CLIENTSPEC` variables defined.", file=sys.stderr)
        raise SystemExit(1)

    # then simply run `p4 sync`
    os.system("p4 sync" + (" -f" if args.forced else ""))

import argparse
parser = argparse.ArgumentParser()
subparsers = parser.add_subparsers(dest="command", help="Commands")
st_parser = subparsers.add_parser("status", aliases=["st"], help="Shows status of workspace files (changed, missing, etc)")
st_parser.set_defaults(func=status)
re_parser = subparsers.add_parser("reconcile", aliases=['re'], help="Interactively reconcile changes.")
re_parser.set_defaults(func=reconcile)
di_parser = subparsers.add_parser("diff", aliases=['di'], help="Show diff, including unopened files.")
di_parser.set_defaults(func=diff)
sync_parser = subparsers.add_parser("update", aliases=['up'], help="Fetches the latest clientspec, updates client view, runs `p4 sync`. May create workspace if needed.")
sync_parser.add_argument("--force", "-f", dest="forced", action="store_true", help="Pass `-f` to `p4 sync`")
sync_parser.add_argument("--create", "-c", dest="create", action="store_true", help="Create workspace if it does not exist")
sync_parser.set_defaults(func=sync)
args = parser.parse_args()

if hasattr(args, 'func'):
    args.func(args)
else:
    parser.print_usage()

